alias: "Deye-Rescue-02 v1.0.0: SOC-Based Discharge Limiter (Simplified)"
description: "Simple SOC-based discharge limiter. Enforces power curve: 50% SOC (3000W) â†’ 25% SOC (1000W). Respects priority: EV Guard > Panic Rescue > SOC Limits. Reacts instantly to any discharge changes."

triggers:
  # React immediately when discharge current changes (ANY value, not just 90A)
  - trigger: state
    entity_id: number.solarcust0186_maximum_battery_discharge_current
  
  # Recalculate when SOC changes
  - trigger: state
    entity_id: sensor.solarcust0186_battery_charge_level
      
  # Home Assistant startup
  - trigger: homeassistant
    event: start
    
  # Periodic check every 1 minute as backup
  - trigger: time_pattern
    minutes: "/1"
    
conditions: []

actions:
  # Step 1: ALWAYS show trigger notification first
  - action: persistent_notification.create
    data:
      notification_id: deye_soc_limiter_trigger
      title: "ðŸ”µ Deye-02 Triggered v1.0.0"
      message: >-
        â° {{ now().strftime('%H:%M:%S') }}
        
        ðŸ“Š SOC: {{ soc }}%
        âš¡ Current: {{ current_cap }}A
        ðŸŽ¯ SOC Limit: {{ soc_limit_a }}A ({{ soc_power_limit_w }}W)
        ðŸ“ˆ Base: {{ base_cap }}A ({{ 'Winter' if is_winter else 'Summer' }})
        
        ðŸš¦ Priority Flags:
        Rescue Active: {{ states('input_boolean.deye_rescue_active') }}
        EV Charging: {{ states('input_boolean.deye_ev_charging_active') }}
        Connection: {{ states('binary_sensor.solarcust0186_connection_status') }}
        
        âœ… Will enforce: {{ (current_cap | round(0) | int) != (soc_limit_a | round(0) | int) }}
        
  # Step 2: Check conditions INSIDE actions
  - condition: state
    entity_id: binary_sensor.solarcust0186_connection_status
    state: "on"
    
  - condition: template
    value_template: "{{ current_cap > 0 }}"
    
  # Don't override if rescue charging is active (Deye-01 has priority)
  - condition: template
    value_template: "{{ states('input_boolean.deye_rescue_active') in ['off', 'unknown', 'unavailable'] }}"
    
  # Don't override if EV charging is active (Deye-03 has priority)
  - condition: template
    value_template: "{{ states('input_boolean.deye_ev_charging_active') in ['off', 'unknown', 'unavailable'] }}"
  
  # Step 3: Enforce SOC-based limit if different from current
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ (current_cap | round(0) | int) != (soc_limit_a | round(0) | int) }}"
        sequence:
          - alias: Set discharge to SOC limit
            target:
              entity_id: number.solarcust0186_maximum_battery_discharge_current
            data:
              value: "{{ soc_limit_a }}"
            action: number.set_value
          
          - alias: Confirm enforcement
            data:
              notification_id: deye_soc_limiter_enforced
              title: "âœ… Deye-02 Enforced v1.0.0"
              message: >-
                â° {{ now().strftime('%H:%M:%S') }}
                
                Changed: {{ current_cap }}A â†’ {{ soc_limit_a }}A
                
                ðŸ“Š SOC: {{ soc }}%
                ðŸ“ˆ Power Limit: {{ soc_power_limit_w }}W
                ðŸ“ Base Cap: {{ base_cap }}A ({{ 'Winter' if is_winter else 'Summer' }})
                
                Calculation:
                min({{ base_cap }}A, {{ soc_limit_a }}A) = {{ soc_limit_a }}A
            action: persistent_notification.create
    default:
      - alias: No change needed
        data:
          notification_id: deye_soc_limiter_skip
          title: "â­ï¸ Deye-02 Skipped v1.0.0"
          message: >-
            â° {{ now().strftime('%H:%M:%S') }}
            
            Already at SOC limit: {{ current_cap }}A = {{ soc_limit_a }}A
            
            ðŸ“Š SOC: {{ soc }}%
            ðŸ“ˆ Power Limit: {{ soc_power_limit_w }}W
        action: persistent_notification.create

mode: queued
max: 10

variables:
  # Base caps (seasonal)
  BASE_WINTER_A: 60
  BASE_SUMMER_A: 90
  month: "{{ now().month }}"
  is_winter: "{{ month in [10,11,12,1,2,3] }}"
  base_cap: "{{ BASE_WINTER_A if is_winter else BASE_SUMMER_A }}"
  
  # SOC-based sliding power caps - continuous linear scale
  # Formula: 80W per percentage point: 50% (3000W) â†’ 25% (1000W)
  SOC_MAX: 50           # Above this: no SOC limit (3000W)
  SOC_MIN: 25           # Below this: hard floor (1000W)
  POWER_MAX: 3000       # Max power at 50% SOC
  POWER_MIN: 1000       # Min power at 25% SOC
  
  # Current sensor values
  soc: "{{ states('sensor.solarcust0186_battery_charge_level') | float(50) }}"
  current_cap: "{{ states('number.solarcust0186_maximum_battery_discharge_current') | float(0) }}"
  
  # Calculate SOC-based power limit with smooth linear curve
  # Formula: POWER_MIN + ((SOC - SOC_MIN) / (SOC_MAX - SOC_MIN)) * (POWER_MAX - POWER_MIN)
  # Example: 36% SOC = 1000 + ((36-25)/(50-25)) * 2000 = 1000 + (11/25) * 2000 = 1880W
  soc_power_limit_w: >-
    {% if soc >= SOC_MAX %}
      {{ POWER_MAX }}
    {% elif soc <= SOC_MIN %}
      {{ POWER_MIN }}
    {% else %}
      {{ POWER_MIN + ((soc - SOC_MIN) / (SOC_MAX - SOC_MIN)) * (POWER_MAX - POWER_MIN) }}
    {% endif %}
  
  # Convert power limit to amps (assuming ~48V average) and apply base cap minimum
  soc_limit_a: "{{ [base_cap, (soc_power_limit_w / 48) | round(0)] | min }}"

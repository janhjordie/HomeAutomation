alias: "Deye-03 v2.10.0: Discharge Cap (SOC-based sliding)"
description: "Discharge current limiter with SOC-based sliding power caps. Respects priority: Deye-09 (EV) > Deye-01 (Rescue) > Deye-03 (SOC limits). Only enforces when neither rescue nor EV charging active. Max 3000W at 50% SOC, down to 1000W at 25% SOC. Checks every 30s to override external changes."

triggers:
  # Main trigger: discharge current number changes
  - trigger: state
    entity_id: number.solarcust0186_maximum_battery_discharge_current
    
  # Recalculate when SOC/voltage/load changes
  - trigger: state
    entity_id:
      - sensor.solarcust0186_battery_voltage
      - sensor.solarcust0186_load_totalpower
      - sensor.solarcust0186_battery_output_power
      - sensor.solarcust0186_battery_soc
      
  # Home Assistant startup
  - trigger: homeassistant
    event: start
    
  # Periodic check every 30s to catch external overrides (SolarBalance, manual changes)
  - trigger: time_pattern
    seconds: "/30"
    
conditions: []  # TEMPORARILY DISABLED - Remove all conditions to see if they're blocking
  # - condition: state
  #   entity_id: binary_sensor.solarcust0186_connection_status
  #   state: "on"
  # - condition: template
  #   value_template: "{{ current_cap > 0 }}"
  # # Don't override if rescue charging is active (Deye-01 has priority)
  # - condition: state
  #   entity_id: input_boolean.deye_rescue_active
  #   state: "off"
  # # Don't override if EV charging is active (Deye-09 has priority)
  # - condition: state
  #   entity_id: input_boolean.deye_ev_charging_active
  #   state: "off"
actions:
  # Debug: Log when automation runs but conditions might block enforcement
  - action: persistent_notification.create
    data:
      notification_id: deye_discharge_cap_trace
      title: "Deye-03 Triggered"
      message: >-
        SOC: {{ soc }}% | Volt: {{ volt }}V
        Current: {{ current_cap }}A | Desired: {{ desired_cap }}A
        Zone: {{ zone_next }}
        
        SOC CALC DEBUG:
        soc_power_limit_w: {{ soc_power_limit_w }}W
        soc_limit_a: {{ soc_limit_a }}A
        base_cap: {{ base_cap }}A ({{ 'Winter' if is_winter else 'Summer' }})
        min({{ base_cap }}, {{ soc_limit_a }}) = {{ [base_cap, soc_limit_a | int] | min }}
        
        Rescue: {{ states('input_boolean.deye_rescue_active') }}
        EV: {{ states('input_boolean.deye_ev_charging_active') }}
        Connection: {{ states('binary_sensor.solarcust0186_connection_status') }}
        Will enforce: {{ (current_cap | round(0) | int) != (desired_cap | round(0) | int) }}
        
  # Check conditions INSIDE actions to avoid blocking
  - condition: state
    entity_id: binary_sensor.solarcust0186_connection_status
    state: "on"
  - condition: template
    value_template: "{{ current_cap > 0 }}"
  # Don't override if rescue charging is active (allow unknown/unavailable = proceed)
  - condition: template
    value_template: "{{ states('input_boolean.deye_rescue_active') in ['off', 'unknown', 'unavailable'] }}"
  # Don't override if EV charging is active (allow unknown/unavailable = proceed)
  - condition: template
    value_template: "{{ states('input_boolean.deye_ev_charging_active') in ['off', 'unknown', 'unavailable'] }}"
        
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ zone_prev in ['unknown','unavailable',''] }}"
        sequence:
          - target:
              entity_id: "{{ zone_entity }}"
            data:
              value: none
            action: input_text.set_value
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ zone_next != zone_prev }}"
        sequence:
          - target:
              entity_id: "{{ zone_entity }}"
            data:
              value: "{{ zone_next }}"
            action: input_text.set_value
  # Always enforce SOC-based limit: check if current matches desired
  # If mismatch detected (SolarBalance or other system changed it), override
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ (current_cap | round(0) | int) != (desired_cap | round(0) | int) }}"
        sequence:
          - target:
              entity_id: number.solarcust0186_maximum_battery_discharge_current
            data:
              value: "{{ desired_cap }}"
            action: number.set_value
          - data:
              notification_id: deye_discharge_cap_debug
              title: "Deye-03 Discharge Cap Set"
              message: >-
                SOC: {{ soc }}% | Volt: {{ volt }}V
                Zone: {{ zone_next }}
                SOC Limit: {{ soc_limit_a }}A ({{ soc_power_limit_w }}W)
                Desired: {{ desired_cap }}A | Was: {{ current_cap }}A
                Base cap: {{ base_cap }}A ({{ 'Winter' if is_winter else 'Summer' }})
            action: persistent_notification.create
mode: queued
max: 10
variables:
  BASE_WINTER_A: 60
  BASE_SUMMER_A: 90
  month: "{{ now().month }}"
  is_winter: "{{ month in [10,11,12,1,2,3] }}"
  base_cap: "{{ BASE_WINTER_A if is_winter else BASE_SUMMER_A }}"
  LOW_A: 60
  DEEP_A: 50
  SUPER_A: 45
  
  # SOC-based sliding power caps - continuous linear scale
  # 80W per percentage point: 50% (3000W) â†’ 25% (1000W)
  SOC_MAX: 50           # Above this: no SOC limit (3000W)
  SOC_MIN: 25           # Below this: hard floor (1000W)
  POWER_MAX: 3000       # Max power at 50% SOC
  POWER_MIN: 1000       # Min power at 25% SOC (hard limit)
  
  volt: "{{ states('sensor.solarcust0186_battery_voltage') | float(999) }}"
  load: "{{ states('sensor.solarcust0186_load_totalpower') | float(0) }}"
  batt_w: "{{ states('sensor.solarcust0186_battery_output_power') | float(0) }}"
  soc: "{{ states('sensor.solarcust0186_battery_soc') | float(50) }}"
  current_cap: >-
    {{ states('number.solarcust0186_maximum_battery_discharge_current') |
    float(0) }}
  
  # Calculate SOC-based power limit with smooth linear curve
  # Formula: POWER_MIN + ((SOC - SOC_MIN) / (SOC_MAX - SOC_MIN)) * (POWER_MAX - POWER_MIN)
  # Example: 36% SOC = 1000 + ((36-25)/(50-25)) * 2000 = 1000 + (11/25) * 2000 = 1880W
  soc_power_limit_w: >-
    {% if soc >= SOC_MAX %}
      {{ POWER_MAX }}
    {% elif soc <= SOC_MIN %}
      {{ POWER_MIN }}
    {% else %}
      {{ POWER_MIN + ((soc - SOC_MIN) / (SOC_MAX - SOC_MIN)) * (POWER_MAX - POWER_MIN) }}
    {% endif %}
  
  # Convert power limit to amps (assuming ~48V average)
  soc_limit_a: "{{ (soc_power_limit_w / 48) | round(0) }}"
  
  primary_zone: input_text.deye_discharge_zone
  fallback_zone: input_text.input_text_deye_discharge_zone
  zone_entity: |-
    {% if states(primary_zone) not in ['unknown', 'unavailable'] %}
      {{ primary_zone }}
    {% else %}
      {{ fallback_zone }}
    {% endif %}
  zone_prev: "{{ states(zone_entity) | lower }}"
  BATT_EXIT_W: 200
  LOAD_EXIT_W: 1500
  V_LOW_ENTER: 49.6
  V_LOW_EXIT: 49.9
  LOAD_LOW_ENTER: 2000
  BATT_LOW_ENTER_W: 800
  V_DEEP_ENTER: 49
  V_DEEP_EXIT: 49.3
  LOAD_DEEP_ENTER: 2600
  BATT_DEEP_ENTER_W: 1500
  V_SUPER_ENTER: 48.6
  V_SUPER_EXIT: 48.9
  LOAD_SUPER_ENTER: 3200
  BATT_SUPER_ENTER_W: 2200
  super_enter: >-
    {{ volt < V_SUPER_ENTER and load > LOAD_SUPER_ENTER and batt_w >
    BATT_SUPER_ENTER_W }}
  super_exit: "{{ volt > V_SUPER_EXIT or load < LOAD_EXIT_W or batt_w < BATT_EXIT_W }}"
  deep_enter: >-
    {{ volt < V_DEEP_ENTER and load > LOAD_DEEP_ENTER and batt_w >
    BATT_DEEP_ENTER_W }}
  deep_exit: "{{ volt > V_DEEP_EXIT or load < LOAD_EXIT_W or batt_w < BATT_EXIT_W }}"
  low_enter: >-
    {{ volt < V_LOW_ENTER and load > LOAD_LOW_ENTER and batt_w >
    BATT_LOW_ENTER_W }}
  low_exit: "{{ volt > V_LOW_EXIT or load < LOAD_EXIT_W or batt_w < BATT_EXIT_W }}"
  
  # Combined zone logic: Use SOC limit as safety floor
  zone_next: |-
    {% if soc <= 20 %}
      super
    {% elif zone_prev == 'super' %}
      {{ 'deep' if super_exit and (not deep_exit) and deep_enter else ('none' if super_exit else 'super') }}
    {% elif zone_prev == 'deep' %}
      {{ 'super' if super_enter else ('low' if deep_exit and (not low_exit) and low_enter else ('none' if deep_exit else 'deep')) }}
    {% elif zone_prev == 'low' %}
      {{ 'super' if super_enter else ('deep' if deep_enter else ('none' if low_exit else 'low')) }}
    {% else %}
      {{ 'super' if super_enter else ('deep' if deep_enter else ('low' if low_enter else 'none')) }}
    {% endif %}
  desired_cap: >-
    {%- if zone_next == 'super' -%}
      {{ [SUPER_A, base_cap, soc_limit_a | int] | min }}
    {%- elif zone_next == 'deep' -%}
      {{ [DEEP_A, base_cap, soc_limit_a | int] | min }}
    {%- elif zone_next == 'low' -%}
      {{ [LOW_A, base_cap, soc_limit_a | int] | min }}
    {%- else -%}
      {{ [base_cap, soc_limit_a | int] | min }}
    {%- endif -%}
